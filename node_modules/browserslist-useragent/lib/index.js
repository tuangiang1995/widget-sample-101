"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeQuery = exports.resolveUserAgent = exports.matchesUA = void 0;
const browserslist_1 = __importDefault(require("browserslist"));
const semver_1 = __importDefault(require("semver"));
const ua_parser_js_1 = __importDefault(require("ua-parser-js"));
// @see https://github.com/ai/browserslist#browsers
// map of equivalent browsers,
// see https://github.com/ai/browserslist/issues/156
const browserNameMap = {
    bb: 'BlackBerry',
    and_chr: 'Chrome',
    ChromeAndroid: 'Chrome',
    FirefoxAndroid: 'Firefox',
    ff: 'Firefox',
    ie_mob: 'ExplorerMobile',
    ie: 'Explorer',
    and_ff: 'Firefox',
    ios_saf: 'iOS',
    op_mini: 'OperaMini',
    op_mob: 'OperaMobile',
    and_qq: 'QQAndroid',
    and_uc: 'UCAndroid',
};
function resolveUserAgent(uaString) {
    const parsedUA = (0, ua_parser_js_1.default)(uaString);
    const parsedBrowserVersion = semverify(parsedUA.browser.version);
    const parsedOSVersion = semverify(parsedUA.os.version);
    const parsedEngineVersion = semverify(parsedUA.engine.version);
    // Case A: For Safari on iOS, the use the browser version
    if (parsedUA.browser.name === 'Safari' && parsedUA.os.name === 'iOS') {
        return {
            family: 'iOS',
            version: parsedBrowserVersion,
        };
    }
    // Case B: The browser on iOS didn't report as safari,
    // so we use the iOS version as a proxy to the browser
    // version. This is based on the assumption that the
    // underlying Safari Engine used will be *atleast* equal
    // to the iOS version it's running on.
    if (parsedUA.os.name === 'iOS') {
        return {
            family: 'iOS',
            version: parsedOSVersion
        };
    }
    if ((parsedUA.browser.name === 'Opera' && parsedUA.device.type === 'mobile') ||
        parsedUA.browser.name === 'Opera Mobi') {
        return {
            family: 'OperaMobile',
            version: parsedBrowserVersion
        };
    }
    if (parsedUA.browser.name === 'Samsung Browser') {
        return {
            family: 'Samsung',
            version: parsedBrowserVersion
        };
    }
    if (parsedUA.browser.name === 'IE') {
        return {
            family: 'Explorer',
            version: parsedBrowserVersion
        };
    }
    if (parsedUA.browser.name === 'IEMobile') {
        return {
            family: 'ExplorerMobile',
            version: parsedBrowserVersion
        };
    }
    // Use engine version for gecko-based browsers
    if (parsedUA.engine.name === 'Gecko') {
        return {
            family: 'Firefox',
            version: parsedEngineVersion
        };
    }
    // Use engine version for blink-based browsers
    if (parsedUA.engine.name === 'Blink') {
        return {
            family: 'Chrome',
            version: parsedEngineVersion
        };
    }
    // Chrome based browsers pre-blink (WebKit)
    if (parsedUA.browser.name &&
        ['Chrome', 'Chromium', 'Chrome WebView', 'Chrome Headless'].includes(parsedUA.browser.name)) {
        return {
            family: 'Chrome',
            version: parsedBrowserVersion
        };
    }
    if (parsedUA.browser.name === 'Android Browser') {
        // Versions prior to Blink were based
        // on the OS version. Only after this
        // did android start using system chrome for web-views
        return {
            family: 'Android',
            version: parsedOSVersion
        };
    }
    return {
        family: parsedUA.browser.name || null,
        version: parsedBrowserVersion
    };
}
exports.resolveUserAgent = resolveUserAgent;
// Convert version to a semver value.
// 2.5 -> 2.5.0; 1 -> 1.0.0;
const semverify = (version) => {
    if (!version) {
        return null;
    }
    const cooerced = semver_1.default.coerce(version, { loose: true });
    if (!cooerced) {
        return null;
    }
    return cooerced.version;
};
// 10.0-10.2 -> 10.0, 10.1, 10.2
function generateSemversInRange(versionRange) {
    const [start, end] = versionRange.split('-');
    const startSemver = semverify(start);
    const endSemver = semverify(end);
    if (!startSemver || !endSemver) {
        return [];
    }
    const versionsInRange = [];
    let curVersion = startSemver;
    while (semver_1.default.gte(endSemver, curVersion)) {
        versionsInRange.push(curVersion);
        curVersion = semver_1.default.inc(curVersion, 'minor');
    }
    return versionsInRange;
}
function normalizeQuery(query) {
    let normalizedQuery = query;
    const regex = `(${Object.keys(browserNameMap).join('|')})`;
    const match = query.match(new RegExp(regex));
    if (match) {
        normalizedQuery = query.replace(match[0], browserNameMap[match[0]]);
    }
    return normalizedQuery;
}
exports.normalizeQuery = normalizeQuery;
const parseBrowsersList = (browsersList) => {
    const browsers = browsersList
        .map((browser) => {
        const [name, version] = browser.split(' ');
        return { name, version };
    })
        // #38 Filter out non-numerical browser versions
        .filter((browser) => browser.version !== 'TP')
        .map((browser) => {
        let normalizedName = browser.name;
        let normalizedVersion = browser.version;
        if (browser.name in browserNameMap) {
            normalizedName = browserNameMap[browser.name];
        }
        // browserslist might return ranges (9.0-9.2), unwrap them
        // see https://github.com/browserslist/browserslist-useragent/issues/41
        if (browser.version.indexOf('-') > 0) {
            return generateSemversInRange(browser.version).map((version) => ({
                family: normalizedName,
                version,
            }));
        }
        else {
            return {
                family: normalizedName,
                version: normalizedVersion,
            };
        }
    });
    return browsers.flat();
};
const compareBrowserSemvers = (versionA, versionB, options) => {
    const semverifiedA = semverify(versionA);
    const semverifiedB = semverify(versionB);
    if (!semverifiedA || !semverifiedB) {
        return false;
    }
    let referenceVersion = semverifiedB;
    if (options.ignorePatch) {
        referenceVersion = `~${semverifiedB}`;
    }
    if (options.ignoreMinor) {
        referenceVersion = `^${semverifiedB}`;
    }
    if (options.allowHigherVersions) {
        return semver_1.default.gte(semverifiedA, semverifiedB);
    }
    else {
        return semver_1.default.satisfies(semverifiedA, referenceVersion);
    }
};
const matchesUA = (uaString, opts = {}) => {
    // bail out early if the user agent is invalid
    if (!uaString) {
        return false;
    }
    let normalizedQuery;
    if (opts.browsers) {
        normalizedQuery = opts.browsers.map(normalizeQuery);
    }
    const browsers = (0, browserslist_1.default)(normalizedQuery, {
        env: opts.env,
        path: opts.path || process.cwd(),
    });
    const parsedBrowsers = parseBrowsersList(browsers);
    const resolvedUserAgent = resolveUserAgent(uaString);
    const options = Object.assign({ ignoreMinor: false, ignorePatch: true }, opts);
    return parsedBrowsers.some((browser) => {
        if (!resolvedUserAgent.family)
            return false;
        if (!resolvedUserAgent.version)
            return false;
        if (!browser.version)
            return false;
        return (browser.family.toLowerCase() ===
            resolvedUserAgent.family.toLocaleLowerCase() &&
            compareBrowserSemvers(resolvedUserAgent.version, browser.version, options));
    });
};
exports.matchesUA = matchesUA;
