"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.legacyPlugin = void 0;
const dev_server_core_1 = require("@web/dev-server-core");
const path_1 = __importDefault(require("path"));
const isLegacyBrowser_js_1 = require("./isLegacyBrowser.js");
const babelTransform_js_1 = require("./babelTransform.js");
const injectPolyfillsLoader_js_1 = require("./injectPolyfillsLoader.js");
const constants_js_1 = require("./constants.js");
const REGEXP_TO_BROWSER_PATH = new RegExp(path_1.default.sep === '\\' ? '\\\\' : path_1.default.sep, 'g');
/**
 * Turns a file path into a path suitable for browsers, with a / as seperator.
 * @param {string} filePath
 * @returns {string}
 */
function toBrowserPath(filePath) {
    return filePath.replace(REGEXP_TO_BROWSER_PATH, '/');
}
function legacyPlugin(options = {}) {
    // index html data, keyed by url
    const inlineScripts = new Map();
    // polyfills, keyed by request path
    const polyfills = new Map();
    let rootDir;
    let logger;
    return {
        name: 'legacy',
        async serverStart(args) {
            ({ logger } = args);
            ({ rootDir } = args.config);
        },
        transformCacheKey(context) {
            return (0, isLegacyBrowser_js_1.isLegacyBrowser)(context, logger) ? 'legacy' : undefined;
        },
        async serve(context) {
            if (!(0, isLegacyBrowser_js_1.isLegacyBrowser)(context, logger)) {
                return;
            }
            /**
             * serve extracted inline module if url matches. an inline module requests has this
             * structure:
             * `/inline-script-<index>?source=<index-html-path>`
             * for example:
             * `/inline-script-2?source=/src/index-html`
             * source query parameter is the index.html the inline module came from, index is the index
             * of the inline module in that index.html. We use these to look up the correct code to
             * serve
             */
            if ((0, dev_server_core_1.isInlineScriptRequest)(context.url)) {
                const sourcePath = context.URL.searchParams.get('source');
                if (!sourcePath) {
                    throw new Error(`${context.url} is missing a source param`);
                }
                const data = inlineScripts.get(sourcePath);
                if (!data) {
                    return undefined;
                }
                const name = path_1.default.basename(context.path);
                const inlineScript = data.inlineScripts.find(f => f.path.split('?')[0] === name);
                if (!inlineScript) {
                    throw new Error(`Could not find inline module for ${context.url}`);
                }
                return {
                    body: inlineScript.content,
                    headers: {
                        'cache-control': 'no-cache',
                        'last-modified': data.lastModified,
                    },
                };
            }
            // serve polyfill from memory if path matches
            const polyfill = polyfills.get(context.path);
            if (polyfill) {
                // aggresively cache polyfills, they are hashed so content changes bust the cache
                return { body: polyfill, headers: { 'cache-control': 'public, max-age=31536000' } };
            }
        },
        async transform(context) {
            if (!(0, isLegacyBrowser_js_1.isLegacyBrowser)(context, logger)) {
                return;
            }
            if (context.response.is('js')) {
                if (context.path.includes('/polyfills/')) {
                    return;
                }
                const config = context.URL.searchParams.get(constants_js_1.PARAM_TRANSFORM_SYSTEMJS) === 'true'
                    ? babelTransform_js_1.systemJsConfig
                    : babelTransform_js_1.es5Config;
                const filePath = (0, dev_server_core_1.getRequestFilePath)(context.url, rootDir);
                const transformed = await (0, babelTransform_js_1.babelTransform)(filePath, context.body, config);
                context.body = transformed;
                return;
            }
            if (context.response.is('html')) {
                const result = await (0, injectPolyfillsLoader_js_1.injectPolyfillsLoader)(context, options.polyfills);
                context.body = result.indexHTML;
                inlineScripts.set(result.htmlPath, Object.assign(Object.assign({}, result), { inlineScripts: result.inlineScripts, lastModified: context.response.headers['last-modified'] }));
                // cache polyfills for serving
                result.polyfills.forEach(p => {
                    let root = context.path.endsWith('/') ? context.path : path_1.default.posix.dirname(context.path);
                    if (!root.endsWith('/')) {
                        root = `${root}/`;
                    }
                    polyfills.set(`${root}${toBrowserPath(p.path)}`, p.content);
                });
            }
        },
        transformImport({ source, context }) {
            if (!(0, isLegacyBrowser_js_1.isLegacyBrowser)(context, logger)) {
                return;
            }
            const prefix = source.includes('?') ? '&' : '?';
            return `${source}${prefix}${constants_js_1.PARAM_TRANSFORM_SYSTEMJS}=true`;
        },
    };
}
exports.legacyPlugin = legacyPlugin;
exports.default = legacyPlugin;
//# sourceMappingURL=legacyPlugin.js.map